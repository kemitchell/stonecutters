#!/usr/bin/env node
const analyze = require('commonform-analyze')
const commonformCommonmark = require('commonform-commonmark')
const revedCompare = require('reviewers-edition-compare')
const revedSpell = require('reviewers-edition-spell')
const commonmark = require('commonmark')
const ejs = require('ejs')
const fs = require('fs')
const glob = require('glob')
const grayMatter = require('gray-matter')
const hash = require('commonform-hash')
const path = require('path')
const rimraf = require('rimraf')
const runParallelLimit = require('run-parallel-limit')
const runSeries = require('run-series')

const BASE_HREF = 'https://stonecutters.law'

const clauses = {}
const forms = {}
const templates = {}
const tags = {}

runSeries([
  readClauses,
  readForms,
  readTemplates,
  checkForConflicts,
  deleteSiteDirectory,
  recreateSiteDirectory,
  copyStaticFiles,
  writeClausePages,
  writeFormPages,
  writeAboutPages,
  writeTagPages,
  writeHomePage
], (error) => {
  if (error) {
    console.error(error)
    process.exit(1)
  }
  process.exit(0)
})

function readClauses (done) {
  glob(path.join('clauses', '*'), (error, clauseDirectories) => {
    if (error) return done(error)
    runSeries(clauseDirectories.map(clauseDirectory => done => {
      const identifier = path.basename(clauseDirectory)
      runSeries([
        readClauseMetadata,
        indexClause,
        readEditions
      ], done)

      function readClauseMetadata (done) {
        fs.readFile(
          path.join(clauseDirectory, 'clause.md'),
          'utf8',
          (error, read) => {
            if (error) return done(error)
            const parts = grayMatter(read)
            clauses[identifier] = {
              identifier,
              title: parts.data.title,
              tags: parts.data.tags || [],
              description: parts.content,
              html: renderCommonMark(parts.content),
              editions: {}
            }
            done()
          }
        )
      }

      function indexClause (done) {
        const clauseTags = clauses[identifier].tags
        clauseTags.forEach(tag => {
          if (tags[tag]) {
            tags[tag].push(identifier)
          } else {
            tags[tag] = [identifier]
          }
        })
        done()
      }

      function readEditions (done) {
        glob(path.join(clauseDirectory, '*'), (error, editionDirectories) => {
          if (error) return done(error)
          const editions = editionDirectories
            .filter(directory => !directory.endsWith('clause.md'))
            .map(directory => path.basename(directory))
            .sort((a, b) => revedCompare(b, a))
          const latest = editions[0]
          const onlyEdition = editions.length === 1
          runSeries(editions.map(edition => done => {
            if (!clauses[identifier]) {
              clauses[identifier] = {
                identifier,
                editions: {}
              }
            }
            const record = clauses[identifier].editions[edition] = {
              spelled: revedSpell(edition)
            }
            runSeries([
              readTerms,
              readNotes,
              readCommentary
            ], done)

            function readTerms (done) {
              fs.readFile(
                path.join(clauseDirectory, edition, 'terms.md'),
                'utf8',
                (error, read) => {
                  if (error) return done(error)
                  const parts = grayMatter(read)
                  record.title = clauses[identifier].title
                  record.identifier = identifier
                  record.edition = edition
                  record.latest = latest
                  record.onlyEdition = onlyEdition
                  record.permalink = `${BASE_HREF}/${identifier}/${edition}`
                  record.editionSpelled = revedSpell(edition)
                  record.frontMatter = parts.data || {}
                  record.markup = parts.content
                  record.parsed = commonformCommonmark.parse(record.markup)
                  record.digest = hash(record.parsed.form)
                  record.termsHTML = renderCommonMark(record.markup)
                  const analysis = analyze(record.parsed.form)
                  const used = Object.keys(analysis.uses)
                  const defined = Object.keys(analysis.definitions)
                  record.notDefined = used.filter(term => !defined.includes(term))
                  done()
                }
              )
            }

            function readNotes (done) {
              readCommonMarkFile('notes.md', 'notes', done)
            }

            function readCommentary (done) {
              readCommonMarkFile('commentary.md', 'commentary', done)
            }

            function readCommonMarkFile (basename, key, done) {
              fs.readFile(
                path.join(clauseDirectory, edition, basename),
                'utf8',
                (error, read) => {
                  if (error) {
                    if (error.code === 'ENOENT') {
                      record[key] = false
                      return done()
                    }
                    return done(error)
                  }
                  record[key] = read
                  record[`${key}HTML`] = renderCommonMark(read)
                  done()
                }
              )
            }
          }), done)
        })
      }
    }), done)
  })
}

function readForms (done) {
  glob(path.join('forms', '*.md'), (error, formPaths) => {
    if (error) return done(error)
    runSeries(formPaths.map(formPath => done => {
      const identifier = path.basename(formPath, '.md')
      if (!forms[identifier]) {
        forms[identifier] = {
          identifier
        }
      }
      fs.readFile(formPath, 'utf8', (error, read) => {
        if (error) return done(error)
        const { content, data } = grayMatter(read)
        forms[identifier] = {
          identifier,
          homepage: data.homepage,
          title: data.title,
          description: data.description,
          tags: data.tags || [],
          content,
          html: renderCommonMark(content)
        }
        done()
      })
    }), done)
  }, (error) => {
    if (error) return done(error)
    console.error(forms)
  })
}

function deleteSiteDirectory (done) {
  rimraf('site', done)
}

function recreateSiteDirectory (done) {
  runSeries([
    done => fs.mkdir('site', done),
    done => fs.mkdir(path.join('site', 'tags'), done)
  ], done)
}

function readTemplates (done) {
  glob(path.join('templates', '*'), (error, files) => {
    if (error) return done(error)
    runSeries(files.map(file => done => {
      const name = path.basename(file, '.ejs')
      fs.readFile(file, 'utf8', (error, template) => {
        if (error) return done(error)
        templates[name] = ejs.compile(template, {
          filename: file
        })
        done()
      })
    }), done)
  })
}

function checkForConflicts (done) {
  const identifiers = Object.keys(clauses)
  const titles = identifiers.map(identifier => clauses[identifier].title)
  const conflicts = titles.reduce((conflicts, element, index, array) => {
    if (array.indexOf(element) !== index && conflicts.indexOf(element) === -1) {
      conflicts.push(element)
    }
    return conflicts
  }, [])
  if (conflicts.length !== 0) {
    return done(new Error(
      'conflicting clause titles: ' + conflicts.join(', ')
    ))
  }
  done()
}

function copyStaticFiles (done) {
  glob(path.join('static', '*'), (error, files) => {
    if (error) return done(error)
    runParallelLimit(files.map(file => done => {
      const basename = path.basename(file)
      fs.copyFile(file, path.join('site', basename), done)
    }), 3, done)
  })
}

function writeClausePages (done) {
  const identifiers = Object.keys(clauses)
  runSeries(identifiers.map(identifier => done => {
    const editions = Object.keys(clauses[identifier].editions)
      .sort((a, b) => revedCompare(b, a))
    runSeries([
      createDirectory,
      writeIndex,
      writeEditions
    ], done)

    function createDirectory (done) {
      fs.mkdir(path.join('site', identifier), done)
    }

    function writeIndex (done) {
      const record = clauses[identifier]
      writeTemplate(
        'clause',
        {
          identifier,
          title: record.title,
          html: record.html,
          editions: Object.keys(clauses[identifier].editions)
            .sort((a, b) => revedCompare(b, a))
            .map(edition => {
              return { code: edition, spelled: revedSpell(edition) }
            })
        },
        path.join('site', identifier, 'index.html'),
        done
      )
    }

    function writeEditions (done) {
      runParallelLimit(editions.map(edition => done => {
        const record = clauses[identifier].editions[edition]

        runSeries([
          writeEdition,
          writeCommentary
        ], done)

        function writeEdition (done) {
          writeTemplate(
            'edition',
            record,
            path.join('site', identifier, `${edition}.html`),
            done
          )
        }

        function writeCommentary (done) {
          if (!record.commentary) return done()
          writeTemplate(
            'commentary',
            record,
            path.join('site', identifier, `${edition}-commentary.html`),
            done
          )
        }
      }), 3, done)
    }
  }), done)
}

function writeFormPages (done) {
  const identifiers = Object.keys(forms)
  runSeries(identifiers.map(identifier => done => {
    writeTemplate(
      'form',
      forms[identifier],
      path.join('site', `${identifier}.html`),
      done
    )
  }), done)
}

function writeAboutPages (done) {
  glob(path.join('about', '*.md'), (error, files) => {
    if (error) return done(error)
    runSeries(files.map(file => done => {
      const basename = path.basename(file, '.md')
      fs.readFile(file, 'utf8', (error, read) => {
        if (error) return done(error)
        const parts = grayMatter(read)
        const title = parts.data.title
        const markup = parts.content
        const html = renderCommonMark(markup)
        writeTemplate(
          'about',
          { title, html },
          path.join('site', `${basename}.html`),
          done
        )
      })
    }), done)
  })
}

function writeTagPages (done) {
  runParallelLimit(Object.keys(tags).map(tag => done => {
    writeTemplate(
      'tag',
      {
        tag,
        clauses: tags[tag]
          .sort()
          .map(identifier => {
            return {
              identifier,
              title: clauses[identifier].title,
              edition: Object.keys(clauses[identifier].editions)
                .sort((a, b) => revedCompare(b, a))[0]
            }
          })
      },
      path.join('site', 'tags', `${tagToSlug(tag)}.html`),
      done
    )
  }), 3, done)
}

function writeHomePage (done) {
  writeTemplate(
    'homepage',
    {
      forms: Object.keys(forms)
        .sort()
        .map(identifier => {
          const record = forms[identifier]
          return {
            identifier,
            archived: record.archived,
            tags: record.tags,
            title: record.title
          }
        })
        .filter(form => !form.archived),
      clauses: Object.keys(clauses)
        .sort()
        .map(identifier => {
          return {
            identifier,
            title: clauses[identifier].title,
            edition: Object.keys(clauses[identifier].editions)
              .sort((a, b) => revedCompare(b, a))[0]
          }
        }),
      tags: Object.keys(tags)
        .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
        .map(tag => { return { title: tag, slug: tagToSlug(tag) } })
    },
    path.join('site', 'index.html'),
    done
  )
}

function writeTemplate (templateKey, data, file, done) {
  let html
  try {
    html = templates[templateKey](data)
  } catch (error) {
    return done(error)
  }
  fs.writeFile(file, html, done)
}

function renderCommonMark (markup) {
  const reader = new commonmark.Parser()
  const writer = new commonmark.HtmlRenderer()
  const parsed = reader.parse(markup)
  return writer.render(parsed)
}

function tagToSlug (tag) {
  return tag.toLowerCase().replace(/ /g, '-')
}
